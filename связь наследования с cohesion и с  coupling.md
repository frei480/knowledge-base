---
tags:
  - АрхитектураПО
---

Вот как **наследование** связано с **cohesion** (связностью) и **coupling** (связанностью между модулями), включая ключевые принципы и примеры:

---

### 1. **Наследование vs Cohesion (Связность внутри класса)**
**Проблема**:  
Наследование может **снижать cohesion**, если подклассы наследуют нерелевантную функциональность.

**Пример нарушения**:  
```java
class Animal {
    void eat() { ... }
    void fly() { ... } // Не нужно земноводным!
}

class Frog extends Animal {
    // Наследует fly(), хотя лягушки не летают!
}
```
**Почему плохо**:  
Низкая связность: `Frog` содержит лишний метод `fly()`, не относящийся к его логике.

**Решение**:  
- Использовать **интерфейсы** вместо наследования:  
```java
interface Eatable { void eat(); }
interface Flyable { void fly(); }

class Sparrow implements Eatable, Flyable { ... } // Высокая связность
class Frog implements Eatable { ... } // Только нужные методы
```

---

### 2. **Наследование vs Coupling (Связанность между классами)**
**Проблема**:  
Наследование создаёт **жёсткую связь (high coupling)** между родителем и потомком.  
→ Изменения в родителе ломают потомков.

**Пример**:  
```java
class Database {
    void save(String data) { ... }
}

class UserDB extends Database {
    @Override
    void save(String data) {
        // Зависит от реализации родителя
    }
}
```
**Риск**: При изменении сигнатуры `save()` в `Database` код `UserDB` сломается.

**Решение**:  
- **Композиция вместо наследования** (принцип SOLID):  
```java
class UserDB {
    private final Database db; // Низкая связанность
    
    UserDB(Database db) { this.db = db; } // Внедрение зависимости
    
    void save(String data) {
        db.save(data); // Делегирование
    }
}
```

---

### 3. **Когда наследование УЛУЧШАЕТ показатели**
**Правильное использование**:  
- Если все потомки **строго соответствуют** логике родителя (высокая связность внутри иерархии).  
- Когда родитель **абстрактен** (низкая связанность благодаря полиморфизму).

**Пример**:  
```java
abstract class Shape { // Высокая связность: только геометрия
    abstract double area();
}

class Circle extends Shape { ... } // Низкая связанность: клиентский код зависит от абстракции Shape
class Square extends Shape { ... }
```

---

### 4. **Критические принципы проектирования**
| Принцип                                                     | Влияние на Cohesion/Coupling   | Пример с наследованием                                   |
| ----------------------------------------------------------- | ------------------------------ | -------------------------------------------------------- |
| **[[SOLID принципы#^90e45b\|LSP (Liskov Substitution)]]**   | Увеличивает связность иерархии | `Rectangle` и `Square` должны быть взаимозаменяемы       |
| **Composition over Inheritance**                            | Снижает coupling               | Замена `extends` на `private final` поле                 |
| **[[SOLID принципы#^4c6f6c\|ISP (Interface Segregation)]]** | Повышает cohesion              | Разделение `Flyable`, `Swimmable` вместо общего `Animal` |

---

### 5. **Опасные антипаттерны**
**Антипаттерн 1: Глубокие иерархии**  
```java
class A → B → C → D // Изменение в A сломает B, C, D (high coupling)
```

**Антипаттерн 2: Наследование реализации**  
```java
class ArrayList extends AbstractList { ... } // Жёсткая связь с родителем
// Лучше: реализация интерфейса List
```

---

### Итоговые правила
1. **Для cohesion**:  
   - Избегайте наследования "просто для повторного кода".  
   - Дробите крупные иерархии на интерфейсы.
2. **Для coupling**:  
   - Предпочитайте **композицию** наследованию.  
   - Используйте **абстрактные классы/интерфейсы** как "буфер" для снижения связанности.  
3. **Тест на наследование**:  
   *"Является ли потомок **подтипом** родителя в рамках предметной области?"*  
   Да → Наследование оправдано.  
   Нет → Используйте композицию.