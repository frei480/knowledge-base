---
tags:
  - SQL
---
Чтобы найти «потеряшки» — документы «Сборочная единица» без парного «Сборочного чертежа» и наоборот — нужно выполнить следующие шаги:

---

### 1. **Предположим, что связь между документами осуществляется через уникальный идентификатор (например, `code` или `parent_id`)**  
Пример структуры таблицы (адаптируйте под вашу схему):

| **Документ**         | **Поля**       |
|-----------------------|----------------|
| Сборочная единица     | `id`, `code`, `name` |
| Сборочный чертеж      | `id`, `code`, `unit_code` (ссылка на код сборочной единицы) |

---

### 2. **Запросы для поиска «потеряшек»**

#### a) **Сборочные единицы без чертежей**  
```sql
SELECT code 
FROM assembly_units 
WHERE code NOT IN (SELECT unit_code FROM assembly_drawings);
```

#### b) **Сборочные чертежи без единиц**  
```sql
SELECT unit_code 
FROM assembly_drawings 
WHERE unit_code NOT IN (SELECT code FROM assembly_units);
```

---

### 3. **Если связь через `id` (например, чертеж имеет `unit_id`)**  
```sql
-- Единицы без чертежей
SELECT id 
FROM assembly_units 
WHERE id NOT IN (SELECT unit_id FROM assembly_drawings);

-- Чертежи без единиц
SELECT unit_id 
FROM assembly_drawings 
WHERE unit_id NOT IN (SELECT id FROM assembly_units);
```

---

### 4. **Если связь неявная (например, по имени или номеру)**  
Допустим, код единицы содержится в названии чертежа:  
```sql
-- Единицы без чертежей
SELECT a.code 
FROM assembly_units a
LEFT JOIN assembly_drawings d ON d.name LIKE CONCAT('%', a.code, '%')
WHERE d.id IS NULL;

-- Чертежи без единиц
SELECT d.name 
FROM assembly_drawings d
LEFT JOIN assembly_units a ON d.name LIKE CONCAT('%', a.code, '%')
WHERE a.id IS NULL;
```

---

### 5. **Проверка на дубликаты**  
Возможно, некоторые единицы или чертежи привязаны к нескольким документам:  
```sql
-- Единицы с несколькими чертежами
SELECT unit_code, COUNT(*) 
FROM assembly_drawings 
GROUP BY unit_code 
HAVING COUNT(*) > 1;

-- Чертежи, привязанные к несуществующим единицам
SELECT unit_code 
FROM assembly_drawings 
WHERE unit_code NOT IN (SELECT code FROM assembly_units);
```

---

### 6. **Визуализация результата**  
Результаты можно представить в виде таблицы:

| **Тип потеряшки**          | **Количество** |
|-----------------------------|----------------|
| Сборочные единицы без чертежей | 11 000 (35 000 – 24 000) |
| Сборочные чертежи без единиц   | 0 (если все чертежи имеют unit_code) |

---

### 7. **Причины расхождений**  
- **Технические ошибки**:  
  - Неправильное удаление документов.  
  - Ошибки в импорте данных.  
- **Бизнес-процессы**:  
  - Чертежи создаются позже единиц (требуется проверить даты создания).  
  - Архивация документов без отметки в системе.

---

### 8. **Рекомендации**  
- Добавьте **внешние ключи** между таблицами для предотвращения «потеряшек».  
- Настройте **триггеры** для автоматической проверки связей.  
- Реализуйте **отчеты-алерты** для мониторинга несвязанных документов.  

Если структура БД неизвестна — уточните поля связи, чтобы адаптировать запросы.
Чтобы найти «потеряшки» с учётом суффикса **СБ** у чертежей, нужно сопоставить коды документов, удаляя/добавляя суффикс. Пример решения:

---

### 1. **Структура данных (пример)**
- **Сборочная единица**: код `ABC123` → соответствующий чертёж должен иметь код `ABC123СБ`.
- **Сборочный чертеж**: код `XYZ789СБ` → соответствующая единица должна иметь код `XYZ789`.

---

### 2. **Запросы для поиска непарных документов**

#### a) **Сборочные единицы без чертежей**
Найти единицы, для которых нет чертежа с кодом `[код_единицы] + 'СБ'`:
```sql
SELECT code 
FROM assembly_units
WHERE NOT EXISTS (
  SELECT 1 
  FROM assembly_drawings 
  WHERE code = CONCAT(assembly_units.code, 'СБ')
);
```

#### b) **Сборочные чертежи без единиц**
Найти чертежи, для которых нет единицы с кодом `[код_чертежа] без 'СБ'`:
```sql
SELECT code 
FROM assembly_drawings
WHERE NOT EXISTS (
  SELECT 1 
  FROM assembly_units 
  WHERE code = REPLACE(assembly_drawings.code, 'СБ', '')
);
```

---

### 3. **Уточнения**
1. **Если суффикс не всегда в конце** (например, `СБ` может быть в середине кода):
   ```sql
   -- Для чертежей: ищем код единицы, удаляя 'СБ' из любого места в строке
   SELECT code 
   FROM assembly_drawings
   WHERE NOT EXISTS (
     SELECT 1 
     FROM assembly_units 
     WHERE code = REPLACE(assembly_drawings.code, 'СБ', '')
   );
   ```

2. **Если суффикс не строго 'СБ'** (например, регистр или пробелы):
   ```sql
   -- Приведение к верхнему регистру и удаление пробелов
   SELECT code 
   FROM assembly_drawings
   WHERE NOT EXISTS (
     SELECT 1 
     FROM assembly_units 
     WHERE UPPER(TRIM(code)) = UPPER(TRIM(REPLACE(assembly_drawings.code, 'СБ', '')))
   );
   ```

3. **Проверка на дубликаты**:
   ```sql
   -- Чертежи с одинаковым кодом (без учета 'СБ')
   SELECT REPLACE(code, 'СБ', '') AS base_code, COUNT(*) 
   FROM assembly_drawings 
   GROUP BY base_code 
   HAVING COUNT(*) > 1;
   ```

---

### 4. **Визуализация результатов**
| **Тип документа**          | **Количество потеряшек** |
|-----------------------------|--------------------------|
| Сборочные единицы без чертежей | 11 000 (35 000 – 24 000) |
| Сборочные чертежи без единиц  | `N` (результат из запроса 2b) |

---

### 5. **Дополнительные проверки**
- **Ложные срабатывания**: Убедитесь, что все чертежи действительно имеют суффикс `СБ`. Если есть исключения — уточните правила формирования кодов.
- **Исторические данные**: Возможно, старые документы создавались без суффикса.
- **Связь через другие поля**: Если связь идет не только по коду, но и по другим атрибутам (например, `parent_id`), объедините условия.

---

### 6. **Пример для ваших данных**
Если в таблице:
- **Сборочные единицы**: 35 000
- **Сборочные чертежи**: 24 000

То:
- **Минимум 11 000 единиц** не имеют парных чертежей (35 000 – 24 000 = 11 000).
- **Чертежи без единиц** могут быть, только если их коды не соответствуют ни одной единице (например, `QWE123СБ`, но нет `QWE123`).

---

### 7. **Рекомендации**
- Добавьте **валидацию** при создании документов: если создается чертёж, проверяйте существование единицы с кодом `[код_чертежа] без 'СБ'`.
- Настройте **индексы** для ускорения поиска:
  ```sql
  CREATE INDEX idx_units_code ON assembly_units(code);
  CREATE INDEX idx_drawings_code ON assembly_drawings(code);
  ```

Понял! Упрощу решение, учитывая структуру таблицы и суффикс **СБ** у чертежей. 

---

### **Простой алгоритм поиска «потеряшек»**
1. **Сборочная единица** должна иметь парный **Сборочный чертеж** с тем же обозначением + суффикс `СБ`.  
2. **Сборочный чертеж** должен иметь парную **Сборочную единицу** с обозначением без суффикса `СБ`.

---

### **Шаг 1. Экспортируем данные**
Получите два списка в Excel/Google Sheets:
- **Список единиц**: обозначения без `СБ` (например, `ABCD0010`).  
- **Список чертежей**: обозначения с `СБ` (например, `ABCD0010СБ`).  

---

### **Шаг 2. Поиск единиц без чертежей**
1. Создайте столбец **«Парный чертеж»** для единиц, добавляя `СБ` к обозначению:  
   ```
   =A2 & "СБ"  # Если обозначение единицы в ячейке A2
   ```
2. Проверьте, есть ли полученное значение в списке чертежей с помощью `VLOOKUP`:  
   ```
   =IF(ISNA(VLOOKUP(B2, Список_чертежей!A:A, 1, FALSE)), "Нет парного чертежа", "OK")
   ```

**Результат**: Все строки с надписью *«Нет парного чертежа»* — потерянные единицы.

---

### **Шаг 3. Поиск чертежей без единиц**
1. Создайте столбец **«Парная единица»** для чертежей, удаляя `СБ` из обозначения:  
   ```
   =LEFT(A2, LEN(A2)-2)  # Если суффикс всегда из 2 символов ("СБ")
   ```
2. Проверьте, есть ли полученное значение в списке единиц:  
   ```
   =IF(ISNA(VLOOKUP(B2, Список_единиц!A:A, 1, FALSE)), "Нет парной единицы", "OK")
   ```

**Результат**: Строки с *«Нет парной единицы»* — потерянные чертежи.

---

### **Шаг 4. Пример для ваших данных**
Допустим, в базе:
- **35 000 единиц** (обозначения: `XXXX0001`, `XXXX0002`, ...).  
- **24 000 чертежей** (обозначения: `XXXX0001СБ`, `XXXX0002СБ`, ...).

**Что найдем**:
- **Единицы без чертежей**: `35 000 – 24 000 = 11 000` (если все чертежи имеют парные единицы).  
- **Чертежи без единиц**: Те, у которых `XXXX####СБ` нет в списке единиц (например, `ZZZZ9999СБ`, но нет `ZZZZ9999`).

---

### **SQL-запросы (если работаете напрямую с БД)**
```sql
-- Сборочные единицы без чертежей
SELECT Обозначение 
FROM documents
WHERE Тип = 'Сборочная единица'
  AND Обозначение || 'СБ' NOT IN (SELECT Обозначение FROM documents WHERE Тип = 'Сборочный чертеж');

-- Сборочные чертежи без единиц
SELECT Обозначение 
FROM documents
WHERE Тип = 'Сборочный чертеж'
  AND REPLACE(Обозначение, 'СБ', '') NOT IN (SELECT Обозначение FROM documents WHERE Тип = 'Сборочная единица');
```

---

### **Итог**
- **Потерянные единицы**: Те, к которым не привязан чертеж (`11 000` в вашем случае).  
- **Потерянные чертежи**: Те, которые ссылаются на несуществующие единицы (надо вычислить через запрос или таблицу).

Если нужно точное количество — предоставьте данные в формате Excel, и я помогу с детальным анализом!

Да, можно использовать **SELF JOIN** в одном запросе, чтобы найти все «потеряшки». Вот решение:

```sql
SELECT 
  d1.Тип, 
  d1.Обозначение,
  CASE 
    WHEN d2.Обозначение IS NULL THEN 'Нет парного документа'
    ELSE 'OK'
  END AS Статус
FROM 
  documents d1
LEFT JOIN documents d2 ON 
  (d1.Тип = 'Сборочная единица' AND d2.Тип = 'Сборочный чертеж' AND d2.Обозначение = CONCAT(d1.Обозначение, 'СБ'))
  OR
  (d1.Тип = 'Сборочный чертеж' AND d2.Тип = 'Сборочная единица' AND d1.Обозначение = CONCAT(d2.Обозначение, 'СБ'))
WHERE 
  d2.Обозначение IS NULL;
```

### Как это работает:
1. **Соединяем таблицу саму с собой** (`documents d1` и `documents d2`).
2. **Условия JOIN**:
   - Если `d1` — сборочная единица, то ищем чертеж с обозначением `d1.Обозначение + 'СБ'`.
   - Если `d1` — сборочный чертеж, то ищем единицу с обозначением `d1.Обозначение без 'СБ'`.
3. **Фильтр `WHERE d2.Обозначение IS NULL`** оставляет только те документы, у которых нет пары.

### Результат:
| Тип                 | Обозначение   | Статус               |
|----------------------|---------------|----------------------|
| Сборочная единица    | ABCD0010      | Нет парного документа|
| Сборочный чертеж     | XYZ123СБ      | Нет парного документа|

---

### Альтернативный вариант с `UNION ALL` (для разделения типов):
```sql
SELECT 
  'Сборочная единица без чертежа' AS Описание,
  u.Обозначение
FROM 
  documents u
LEFT JOIN documents c ON 
  c.Тип = 'Сборочный чертеж' AND c.Обозначение = CONCAT(u.Обозначение, 'СБ')
WHERE 
  u.Тип = 'Сборочная единица' AND c.Обозначение IS NULL

UNION ALL

SELECT 
  'Сборочный чертеж без единицы' AS Описание,
  c.Обозначение
FROM 
  documents c
LEFT JOIN documents u ON 
  u.Тип = 'Сборочная единица' AND c.Обозначение = CONCAT(u.Обозначение, 'СБ')
WHERE 
  c.Тип = 'Сборочный чертеж' AND u.Обозначение IS NULL;
```

### Результат:
| Описание                     | Обозначение   |
|------------------------------|---------------|
| Сборочная единица без чертежа| ABCD0010      |
| Сборочный чертеж без единицы | XYZ123СБ      |

---

### Почему это лучше:
1. **Один запрос** — охватывает все типы «потеряшек».
2. **Четкое разделение** — видно, к какому типу относится проблема.
3. **Производительность** — `LEFT JOIN` с `NULL` проверкой работает быстро даже на больших данных.

Вот адаптированный запрос для PostgreSQL:

```sql
SELECT 
  t1."Тип", 
  t1."Обозначение",
  CASE 
    WHEN t1."Тип" = 'Сборочная едница' AND t2."Обозначение" IS NULL THEN 'нет СБ'
    WHEN t1."Тип" = 'Сборочный чертеж' AND t2."Обозначение" IS NULL THEN 'нет СП'
    ELSE 'ОК'    
  END AS "Статус"
FROM 
  public."t_Search" AS t1
LEFT JOIN public."t_Search" AS t2 
  ON (
    t1."Обозначение" = CONCAT(t2."Обозначение", 'СБ') 
    OR 
    t2."Обозначение" = CONCAT(t1."Обозначение", 'СБ')
  )
WHERE 
  t2."Обозначение" IS NULL;
```

### Основные изменения:
1. **Синтаксис кавычек**:
   - Использованы двойные кавычки `"` для имён таблиц/столбцов (PostgreSQL чувствителен к регистру при использовании кавычек).
   - Если в вашей схеме таблица называется не `t_Search`, а, например, `t_search` (в нижнем регистре), кавычки можно убрать.

2. **Схема и таблица**:
   - Заменено `[test_database].[dbo].t_Search` на `public."t_Search"` (предполагается, что таблица находится в схеме `public`).

3. **CONCAT()**:
   - Функция `CONCAT` работает в PostgreSQL аналогично MS SQL.

### Как проверить результат:
Запрос вернёт:
- Все **сборочные единицы**, у которых нет чертежа с суффиксом `СБ`.
- Все **сборочные чертежи**, у которых нет единицы с таким же обозначением без `СБ`.

Пример вывода:

| Тип                 | Обозначение | Статус  |
|----------------------|-------------|---------|
| Сборочная едница     | ABCD0010    | нет СБ  |
| Сборочный чертеж     | XYZ123СБ    | нет СП  |

---

### Если нужно разделить типы «потеряшек»:
```sql
-- Отдельно единицы без чертежей
SELECT 'Сборочная едница без чертежа' AS "Тип_проблемы", t1."Обозначение"
FROM public."t_Search" t1
LEFT JOIN public."t_Search" t2 
  ON t2."Обозначение" = CONCAT(t1."Обозначение", 'СБ')
WHERE t1."Тип" = 'Сборочная едница' AND t2."Обозначение" IS NULL

UNION ALL

-- Отдельно чертежи без единиц
SELECT 'Сборочный чертеж без единицы' AS "Тип_проблемы", t1."Обозначение"
FROM public."t_Search" t1
LEFT JOIN public."t_Search" t2 
  ON t1."Обозначение" = CONCAT(t2."Обозначение", 'СБ')
WHERE t1."Тип" = 'Сборочный чертеж' AND t2."Обозначение" IS NULL;
```

Этот вариант более читаем и исключает потенциальные ошибки из-за `OR` в `JOIN`.


Вот пример реализации запроса на SQLAlchemy 2.0 с использованием ORM-подхода:

```python
from sqlalchemy import select, case, or_, and_, func, String
from sqlalchemy.orm import aliased

# Предполагаем, что есть модель Search (соответствует таблице t_Search)
class Search(Base):
    __tablename__ = 't_Search'
    id = Column(Integer, primary_key=True)
    Тип = Column(String, nullable=False)  # 'Сборочная едница' или 'Сборочный чертеж'
    Обозначение = Column(String, nullable=False)

# Создаем алиасы для самосоединения
t1 = aliased(Search, name='t1')
t2 = aliased(Search, name='t2')

# Строим CASE выражение
status_case = case(
    (
        and_(
            t1.Тип == 'Сборочная едница',
            t2.Обозначение.is_(None)
        ),
        'нет СБ'
    ),
    (
        and_(
            t1.Тип == 'Сборочный чертеж',
            t2.Обозначение.is_(None)
        ),
        'нет СП'
    ),
    else_='ОК'
).label('Статус')

# Собираем запрос
query = (
    select(
        t1.Тип,
        t1.Обозначение,
        status_case
    )
    .select_from(t1)
    .outerjoin(
        t2,
        or_(
            t1.Обозначение == func.concat(t2.Обозначение, 'СБ'),
            t2.Обозначение == func.concat(t1.Обозначение, 'СБ')
        )
    )
    .where(t2.Обозначение.is_(None))
)
```

Ключевые моменты:
1. Используем `aliased()` для создания самосоединения
2. `func.concat()` для работы с строковыми функциями PostgreSQL
3. `case()` для реализации условия ветвления
4. `outerjoin()` с комбинированными условиями через `or_()`
5. Фильтрация через `.where(t2.Обозначение.is_(None))`

Для выполнения запроса:
```python
with Session(engine) as session:
    result = session.execute(query)
    for row in result:
        print(f"Тип: {row.Тип}, Обозначение: {row.Обозначение}, Статус: {row.Статус}")
```

Если нужно использовать Core-подход вместо ORM:
```python
from sqlalchemy import table, column

t_search = table(
    't_Search',
    column('Тип', String),
    column('Обозначение', String)
)

t1 = t_search.alias('t1')
t2 = t_search.alias('t2')

query = (
    select(
        t1.c.Тип,
        t1.c.Обозначение,
        case(
            (and_(t1.c.Тип == 'Сборочная едница', t2.c.Обозначение.is_(None)), 'нет СБ'),
            (and_(t1.c.Тип == 'Сборочный чертеж', t2.c.Обозначение.is_(None)), 'нет СП'),
            else_='ОК'
        ).label('Статус')
    )
    .select_from(t1)
    .outerjoin(
        t2,
        or_(
            t1.c.Обозначение == func.concat(t2.c.Обозначение, 'СБ'),
            t2.c.Обозначение == func.concat(t1.c.Обозначение, 'СБ')
        )
    )
    .where(t2.c.Обозначение.is_(None))
)
```