---
tags:
  - АрхитектураПО
Автор: Arjan Egges
Название: A GUIDE FOR DESIGNING GREAT SOFTWARE THAT’S EASY TO WORK ON
---
Вы когда-нибудь застревали, пытаясь найти способ написать программное обеспечение, которое может решить
сложную проблему, но при этом не превратиться в огромный беспорядок спагетти-кода? Вы
часто оказываетесь в ситуации, когда вы знаете, что ваше программное обеспечение должно в конечном итоге делать,
но не знаете, как или с чего начать? Я был в такой ситуации много раз, как и вы,
и я написал этот 7-шаговый план, который поможет вам последовательно разрабатывать отличное программное обеспечение,
над которым легко работать.
Когда вы разрабатываете новую часть программного обеспечения или добавляете новую функцию в существующее программное
приложение, есть много вещей, о которых нужно подумать. Будет полезно, если вы запишете свои
мысли о дизайне вашего программного обеспечения (даже если это всего лишь небольшое обновление). Это не только
позволит вам не забыть ничего важного, но и потренирует ваши
навыки проектного мышления.
Я не рекомендую хаотично записывать свои мысли. Полезно иметь
фреймворк, чтобы вам было легче организовывать свои мысли. Ниже вы найдете структуру,
которую я использую, разделенную на 7 различных разделов. Под названием каждого раздела я добавил
маркированный список основных моментов, которые следует осветить в этом разделе. Я также добавил несколько личных заметок
в каждом разделе (в основном, некоторые случайные мысли и размышления).
Надеюсь, вы найдете это полезным и что это поможет вам улучшить свои разработки программного обеспечения —
давайте углубимся!
# 1. ОПРЕДЕЛИТЕ, ЧТО ВЫ СОЗДАЕТЕ
- Что такое программное приложение или функция?
- Для кого оно предназначено?
- Какую проблему решает программное обеспечение?
- Как оно будет работать?
- Каковы основные концепции, которые задействованы, и как они связаны?

Самый первый шаг — определить, что делает ваше программное приложение или функция. Для этого есть несколько стандартизированных процессов. Лично я много работаю с Domain-Driven Design (Эрика Эванса), хотя это произошло скорее как спонтанное поведение, чем из-за того, что я прочитал книгу и применил идеи.

Самое важное в Domain-Driven Design — это то, что он фокусируется на получении некой ранней реализации, грубого прототипа, основанного на модели домена. На практике не тратьте все свое время на создание идеального дизайна, а затем на его реализацию. Вместо этого делайте это параллельно! Когда вы разрабатываете дизайн для своего программного обеспечения, анализируя домен, невероятно полезно начать работать над какой-то реализацией. Это позволяет вам почувствовать техническую настройку вашего программного обеспечения. Вы можете обнаружить технические ограничения, которые влияют на дизайн вашего программного обеспечения. В то же время анализ домена может также привести к новым представлениям о том, как должна работать технология.

Не стесняйтесь удалять вещи (это называется «дистилляция модели»). Удаляя вещи, вы упрощаете свой дизайн, и это позволяет вам сосредоточиться на том, что важно: на основе того, что должно делать ваше программное обеспечение. Помните, что лучший тип рефакторинга — это удаление кода.

Когда вы определяете, что делает программное приложение или функция, какие концепции задействованы и как все связано, я часто следую подходу «уменьшения и увеличения». В качестве первого шага я стараюсь думать как можно шире о программном обеспечении и о том, что оно повлечет за собой («уменьшения»). Самое забавное, что я заметил за эти годы, заключается в том, что, становясь более опытным проектировщиком и разработчиком программного обеспечения, я трачу все больше времени на эту концептуальную стадию и все меньше времени на ее реализацию. Реализация почти становится второстепенной: это просто последний шаг перевода концепций и взаимосвязей, которые я записал, в код, который компьютер может понять и запустить. Однако, особенно если вы принимаете методологию выполнения проектирования и внедрения в тандеме, границы между проектированием и внедрением, как правило, становятся размытыми.

После уменьшения масштаба вам нужно снова увеличить масштаб. Что мы должны сделать в первую очередь? Есть ли части, которые мы можем отложить создание? Что является низко висящим фруктом? Как порядок построения вещей влияет на сложность работы? Есть ли части, которые мы должны построить в первую очередь, чтобы мы могли быстрее все протестировать, что приведет к более эффективной разработке позже?

С точки зрения бизнеса это также называется определением MVP (минимально жизнеспособного продукта). Цель состоит в том, чтобы выполнить минимальную работу, необходимую для того, чтобы иметь возможность проверить, полезно ли то, что вы создаете, и (если применимо) может ли оно стать основой бизнеса.
# 2. Спроектируйте Пользовательский Опыт
- Каковы основные пользовательские истории (счастливые потоки + альтернативные потоки)?
- Если вы добавляете новую функцию в существующее программное приложение, какое влияние эта функция оказывает на общую структуру интерфейса? (существуют ли большие изменения в организации меню, навигации и т. д.?)

Вы также можете предоставить здесь макеты пользовательского интерфейса или фреймворки как часть пользовательских историй, чтобы прояснить, как будут выглядеть потоки.

Когда я проектирую программное обеспечение, я всегда должен напоминать себе, что я делаю это для кого-то другого, а не для того, чтобы похлопать себя по спине за то, что нашел такой хороший дизайн. То, что вы проектируете, должно иметь смысл для пользователя. Иногда это означает, что вам нужно ввести дополнительную концепцию,
чтобы прояснить, как работает ваша система. А иногда самое общее решение не является лучшим решением для пользователя.

> [!note]
> Например, в прошлом я работал над программной платформой для школ и университетов. Мы хотели добавить аналитическую панель управления на платформу. Я создал это очень общее решение, которое позволяло клиентам создавать собственную аналитическую панель управления и определять пользовательские аналитические блоки, где клиенты могли писать свой собственный код Python для выполнения фактической аналитики. Это было очень общее и мощное решение, но ни один клиент не использовал его, потому что им просто не нужна была сложная аналитика.
> Моя ошибка была в том, что я не проверял, действительно ли пользователям нужно что-то, прежде чем создавать это. В настоящее время я стараюсь упрощать вещи и трачу время только на реализацию того, что, как я знаю, принесет пользу пользователям. По моему опыту, создание пользовательских интерфейсов является одним из самых трудоемких процессов создания программного обеспечения. Тем более, что каждое изменение пользовательского интерфейса также означает написание документации, общение с вашими существующими пользователями и потенциальное внесение ошибок, которые вам нужно будет устранить в будущем.

# 3. ПОНИМАЙТЕ ТЕХНИЧЕСКИЕ ПОТРЕБНОСТИ
- Какие технические детали должны знать разработчики для разработки программного обеспечения или новой функции?
- Нужны ли новые таблицы для добавления в базу данных? Какие поля?
- Как будет технически работать программное обеспечение? Есть ли определенные алгоритмы или библиотеки, которые важны?
- Какой будет общая конструкция? Какие классы необходимы? Какие шаблоны проектирования используются для моделирования концепций и отношений?
- Какое стороннее программное обеспечение необходимо для создания программного обеспечения или функции?

Вы можете использовать UML для рисования основных классов, которые будут добавлены, и того, как они вписываются в остальную часть системы. Мне нравится использовать Mermaid для рисования диаграмм, так как это основано на тексте. Кроме того, многие инструменты для разработчиков, такие как GitHub или VS Code, поддерживают визуализацию диаграмм Mermaid. При написании кода следует помнить о нескольких простых вещах, которые помогут вам писать код, который легко поддерживать:

**a. Используйте функции вместо классов.**

По моему опыту, функциональный код обычно проще объектно-ориентированного кода. Особенно в таких языках, как Python или Rust, легко писать отличный функциональный код, поскольку эти языки хорошо поддерживают концепции функционального программирования. Если вы заметили, что вам нужно передавать слишком много вещей в качестве аргументов вашим функциям или если вам нужно какое-то представление объекта для данных, это отличное время для введения класса.

**b. Делайте вещи небольшими и простыми.**
Это верно, независимо от того, думаете ли вы о модулях, функциях, методах или количестве переменных экземпляра в классе. Ваш код будет легче читать и тестировать.

**c. Отделяйте создание вещи от ее использования.**
Не создавайте объект, а затем немедленно вызывайте методы для него. Вместо этого создайте объект вне функции и передайте его в качестве аргумента. Это упростит тестирование вашего кода.

**d. Используйте абстракцию.**
В Python вы можете использовать ABC или протоколы. В Rust вы можете использовать Traits. В любом случае, они помогают вам удалить зависимости, и это снижает вероятность поломки при работе над кодом.

Простое выполнение этих действий уже очень помогает сохранять ваш код простым и легким для работы. Я часто рассказываю о таких концепциях в видео на моем канале YouTube, поэтому посмотрите их для получения более подробной информации и примеров кода.

Наконец, на этом этапе вам, возможно, захочется описать конкретные пограничные случаи, которые вы хотите, чтобы система обрабатывала правильно, например, что должно произойти в случае ошибки сетевого подключения.

# 4. РЕАЛИЗУЙТЕ ТЕСТИРОВАНИЕ И МЕРЫ БЕЗОПАСНОСТИ
- Существуют ли конкретные цели покрытия для модульных тестов?
- Какие виды тестов необходимы (модульные, регрессионные, сквозные и т. д.)?
- (только для новой функции) Есть ли какие-либо потенциальные побочные эффекты в других областях приложения при добавлении этой функции?
- Какие проверки безопасности необходимо провести, чтобы разрешить отправку программного обеспечения?
- (только для новой функции) Как функция влияет на безопасность программного обеспечения? Нужна ли проверка безопасности перед отправкой функции?

Все всегда говорят о том, насколько важно тестирование, в основном потому, что оно помогает вам находить ошибки и создавать более качественный, более надежный код. Это часть этого, но есть гораздо более важная причина сделать тестирование частью того, как вы работаете: проектируя и пишете код, который легко тестировать, вы развиваете мышление тестировщика. Мышление, что каждый фрагмент кода потенциально что-то ломает. Мышление, которое по умолчанию учитывает пограничные случаи. Если вы примете это мышление, вы начнете автоматически организовывать свой код так, чтобы пограничные случаи обрабатывались почти автоматически. Проектируйте интерфейсы, классы и методы таким образом, чтобы они подталкивали пользователей следовать счастливому потоку.

Например, предположим, что вы пишете функцию, которая извлекает пользователей из вашей базы данных с определенной ролью. Вы можете использовать строковый
аргумент, чтобы указать имя роли. Проблема в том, что вы открываете возможность вызова этой функции с ролями, которые не существуют. И тогда вам придется писать дополнительный код для обработки этого пограничного случая, а также дополнительные тесты, чтобы убедиться, что вы обрабатываете его правильно. Другой вариант - использовать Enum вместо этого. Тогда вы полагаетесь на то, что система типизации обработает пограничный случай за вас, экономя вам много дополнительной работы.
Вот почему так много разработчиков любят языки со строгой проверкой типов: они обнаруживают проблемы на ранней стадии, поэтому вам не придется иметь дело с ними позже, когда код уже отправлен, а клиенты сталкиваются с ошибками.

В общем, убедитесь, что с вашим кодом легко работать. Это поможет, если вы остановитесь на стандарте кодирования и будете использовать вспомогательные инструменты, чтобы облегчить себе жизнь. Не пытайтесь быть слишком навороченным. В случае Python, наличие автоматического линтера, такого как Black или Ruff, уже поможет, как и следование лучшим практикам кодирования на Python (у меня есть много видео на моем канале, подробно освещающих это).

Python очень свободен в отношении типизации и ошибок. Когда вы только начинаете кодировать, это хорошо, потому что вы можете очень быстро начать, не думая слишком много о пограничных случаях. Однако в долгосрочной перспективе это означает, что как разработчику вам нужно развить хорошее чувство того, как будут использоваться ваши скрипты. Rust, с другой стороны, является полной противоположностью: у него значительная кривая обучения, и когда вы пишете код Rust в первый раз, вам может показаться, что вы постоянно боретесь с компилятором. Однако это означает, что вам придется иметь дело с пограничными случаями перед отправкой кода,
что приводит к более надежному программному обеспечению.

Пишите свои тесты, предполагая, что вы собираетесь что-то менять в процессе разработки: не сосредотачивайтесь на достижении 100% тестового покрытия, несмотря ни на что. Вместо этого сосредоточьтесь на выполнении базовой версии функции, чтобы вы могли оценить, действительно ли это то, что нужно вам или вашим пользователям. Фактически, предполагайте, что каждую строку кода, которую вы пишете, вы выбросите в какой-то момент: не привязывайтесь к коду, который вы пишете.

# 5. ПЛАНИРУЙТЕ РАБОТУ
- Сколько времени будет стоить разработка программного обеспечения или функции?
- Каковы шаги и сколько времени занимает шаг?
- Каковы основные этапы разработки и в каком порядке?
- Необходимо ли писать какие-либо сценарии миграции?
- Каковы основные факторы риска и есть ли альтернативные пути, которые можно использовать, если вы обнаружите, что что-то невыполнимо?
- Какие части являются абсолютно необходимыми, а какие части можно выполнить по желанию на более позднем этапе? (т. е. Определение готовности)

> [!NOTE]
> Особенно, если вы начинающий разработчик, трудно оценить, сколько времени занимает разработка части программного обеспечения. Вы станете лучше в этом, сделав это пару раз. Что мне помогает, так это сначала выяснить, каковы основные факторы риска. Например, если вы хотите добавить функцию, которая позволяет пользователям интегрировать ваше приложение с Microsoft Teams, основным фактором риска является процесс создания фактического кода интеграции (который вероятно, будет частично находиться в магазине приложений Teams), а не добавления пользовательского интерфейса в вашем приложении для его настройки. Чем больше факторов риска у вас в проекте программного обеспечения, тем больше времени вам нужно зарезервировать для неприятных сюрпризов.

# 6. Определите Эффект Ряби
- Что необходимо сделать помимо проектирования и внедрения функции?
- Какую документацию необходимо обновить?
- Нужно ли вам что-то сообщить существующим пользователям?
- Есть ли другие внешние системы, которые необходимо обновить? Например, платежный провайдер, email-маркетинг, система продаж?

Как технический специалист, легко попасть в ловушку, что единственное, что нужно сделать, это создать само программное обеспечение или функцию. Однако я узнал, что все процессы и задачи, связанные с разработкой программного обеспечения, выпуском его для клиента и обеспечением того, чтобы клиенты могли успешно использовать программное обеспечение, занимают много времени. Хотя это может быть не всегда важно, и вы можете не быть тем человеком, который выполняет эти задачи, я считаю полезным заранее думать об этих вещах, когда я работаю над программным обеспечением, чтобы они не возникали в последнюю минуту.

Особенно для программного обеспечения, у которого много пользователей, важно думать о волновых эффектах изменения программного обеспечения. Вот почему иногда кажется, что крупные компании-разработчики программного обеспечения движутся невероятно медленно. Это потому, что волновые эффекты для крупных компаний огромны, поэтому им нужно тратить много времени, чтобы убедиться, что они правильно обработаны!

# 7. Понимайте Более Широкий Контекст
- Каковы ограничения текущего дизайна?
- Какие возможные расширения стоит рассмотреть в будущем?
- Какие еще соображения следует принять во внимание, например, бюджет?

Всякий раз, когда я разрабатываю программное обеспечение, я всегда люблю включать несколько «прорывных» идей: «Было бы очень круто, если бы программное обеспечение также могло делать X». Причина, по которой это полезно, заключается в том, что это делает вас очень открытым, что иногда приводит к новым идеям. Кроме того, когда вы разрабатываете программное обеспечение, возможно, вас озаряет, что позволяет вам добавить одну из этих прорывных идей. Это потрясающе, когда это происходит!

Наконец, знание ограничений вашего дизайна поможет вам улучшить программное обеспечение в долгосрочной перспективе, поскольку это даст вам немедленную отправную точку, когда вам нужно будет вносить изменения в свое программное обеспечение в будущем.

Вы могли заметить, что я не особо много говорил о шаблонах проектирования в этом руководстве. Это сделано намеренно. Самый важный этап создания отличного дизайна - это понимание проблемы, которую вы пытаетесь решить. Это шаг, который пропускают многие разработчики, но это важная часть проектирования
отличного программного обеспечения!

Изучение и освоение шаблонов и принципов проектирования - это следующий этап, поэтому я обещаю, что подробно обсужу их с вами в будущем. А пока, я надеюсь,
это руководство даст вам пищу для размышлений, когда мы начнем работать вместе, чтобы помочь вам стать экспертом по проектированию программного обеспечения.