---
tags:
  - rust
---
[[Алгебраические типы данных в Rust|АТД (Алгебраические Типы Данных) в Rust]] — это мощный инструмент, который **исключает целые классы ошибок на этапе компиляции** благодаря системе типов и pattern matching. Рассмотрим конкретный пример: моделирование состояния пользователя в системе аутентификации.

# Проблема Без АТД
Допустим, мы хотим представить состояние пользователя:
- Не аутентифицирован
- Аутентифицирован
- Заблокирован

Без АТД часто используют примитивные типы:
```rust
struct User {
    id: u64,
    is_authenticated: bool,
    is_blocked: bool,
}
```
**Проблемы:**
1. Невозможные состояния: `is_authenticated=true` и `is_blocked=true` одновременно?
2. Ошибки в runtime: проверки вида `if user.is_authenticated && !user.is_blocked` рассыпаны по коду.
3. Сложность масштабирования: добавление нового состояния (например, `MFARequired`) требует переписывания логики.

---

# Решение С АТД (enum + struct)
Используем `enum` для явного описания состояний:
```rust
enum UserState {
    Unauthenticated,
    Authenticated { session_token: String }, // данные, специфичные для состояния
    Blocked { reason: String },
}

struct User {
    id: u64,
    state: UserState, // состояние как АТД
}
```

# Как Это Предотвращает Ошибки?
## 1. Исключаем Невалидные Состояния
Компилятор гарантирует, что **только одно состояние** активно в каждый момент. Невозможно:
- Одновременно иметь `session_token` и `reason` блокировки
- Находиться в состоянии "аутентифицирован" и "заблокирован"

## 2. Pattern Matching Требует Обработки Всех Вариантов
```rust
fn can_access_settings(user: &User) -> bool {
    match user.state {
        UserState::Authenticated { .. } => true,
        UserState::Blocked { .. } | UserState::Unauthenticated => false,
    }
    // Компилятор выдаст ошибку, если забыли обработать Unauthenticated!
}
```

## 3. Безопасное Расширение
Добавим новое состояние `MFARequired`:
```rust
enum UserState {
    // ...,
    MFARequired { phone: String },
}
```
**Компилятор сразу укажет** все места, где нужно обработать новый кейс — никаких скрытых runtime-ошибок!

## 4. Данные Привязаны К Состояниям
- `session_token` существует **только** в `Authenticated`
- `reason` есть **только** в `Blocked`

Попытка доступа к `session_token` в состоянии `Blocked` — ошибка компиляции:
```rust
if let UserState::Blocked { reason } = user.state {
    println!("Blocked reason: {}", reason);
    // session_token недоступен здесь!
}
```

---

# Реальный Пример: Обработка Аутентификации
```rust
fn handle_login(user: &mut User, token: String) {
    user.state = match user.state {
        UserState::Unauthenticated => UserState::Authenticated {
            session_token: token,
        },
        _ => {
            // Компилятор заставляет явно обработать
            // попытку входа для не-Unauthenticated
            println!("Invalid state transition!");
            return;
        }
    };
}
```

# Какие Ошибки Предотвращаются?
1. **Невозможные состояния:** Тип `UserState` описывает только валидные комбинации.
2. **Необработанные кейсы:** `match` требует явной обработки всех вариантов.
3. **Ошибки данных:** Доступ к полям возможен только в корректных состояниях.
4. **Невалидные переходы:** Логика смены состояний контролируется на этапе компиляции.

---

# Почему Это Важно?
- **Устраняет целые классы багов:** Нет нужды в тестах на "невозможные" сценарии вроде `is_blocked && is_authenticated`.
- **Самодокументируемость:** Код явно описывает все состояния и переходы.
- **Безопасные изменения:** Добавление нового состояния не сломает существующую логику — компилятор укажет, что нужно обновить.

АТД в Rust — это не просто синтаксис, а **философия проектирования**, которая переносит обнаружение ошибок из runtime в compile-time, делая программы принципиально более надежными.