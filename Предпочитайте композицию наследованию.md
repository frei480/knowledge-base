---
tags:
  - АрхитектураПО
---

Предпочитайте композицию наследованию - один из краеугольных камней гибкого и поддерживаемого ООП. Давайте разберем его подробно.

**Суть принципа:**

*   **Наследование (Inheritance):** Отношение **"является" (is-a)**. Класс-потомок наследует структуру (поля) и поведение (методы) класса-родителя и может их дополнять или изменять. (Пример: `Dog` *is an* `Animal`).
*   **Композиция (Composition):** Отношение **"имеет" (has-a)**. Класс содержит в себе один или несколько объектов других классов в качестве своих полей и использует их функциональность, делегируя им задачи. (Пример: `Car` *has an* `Engine`).

**Принцип гласит:** Когда вам нужно повторно использовать код или расширить функциональность, **сначала рассмотрите возможность использования композиции (включения объекта) вместо автоматического выбора наследования.**

**Почему наследование часто становится проблемой (и почему композиция предпочтительнее):**

1.  **Жесткая связь (Tight Coupling):**
    *   **Наследование:** Потомок **жизненно зависит** от реализации родителя. Любое изменение в родителе (особенно в невиртуальных методах или полях) может неожиданно сломать потомков, даже если они находятся в разных модулях.
    *   **Композиция:** Классы связаны **гораздо слабее**. Класс-контейнер зависит только от *интерфейса* (публичного контракта) компонента, который он использует, а не от его внутренней реализации. Реализацию компонента можно легко подменить (например, через внедрение зависимости).

2.  **Хрупкость базового класса (Fragile Base Class Problem):**
    *   **Проблема:** Изменение, казалось бы, безобидного метода в базовом классе может нарушить работу непредвиденного количества классов-потомков, даже если они находятся в коде, написанном другими людьми или давно не менявшемся. Это происходит потому, что потомки полагаются на детали реализации (а не только на интерфейс) родителя.
    *   **Композиция:** Изменение внутренней реализации компонента (при сохранении его интерфейса) **не влияет** на класс-контейнер, который его использует.

3.  **Нарушение инкапсуляции:**
    *   **Наследование:** Потомок получает доступ к `protected` (а иногда и `public`) полям и методам родителя. Это часто приводит к тому, что внутреннее состояние родителя "просачивается" в потомка, нарушая принцип сокрытия информации. Потомок может начать манипулировать внутренностями родителя непредусмотренным образом.
    *   **Композиция:** Класс-компонент **полностью инкапсулирован**. Класс-контейнер взаимодействует с ним **только** через его четко определенный публичный интерфейс. Внутреннее состояние компонента скрыто.

4.  **Ограниченная гибкость иерархий (Проблема взрыва иерархии - Exploding Class Hierarchy):**
    *   **Проблема:** Реальные объекты часто обладают множеством независимых характеристик. Попытка смоделировать это через наследование приводит к экспоненциальному росту числа классов или к неестественным иерархиям.
        *   *Пример:* `Car` наследует от `Vehicle`. Нужна машина с `GPS`? Делаем `CarWithGPS`. Нужна машина с `GPS` и `Sunroof`? `CarWithGPSAndSunroof`. Нужна машина *только* с `Sunroof`? `CarWithSunroof`. Количество классов растет как 2^N.
    *   **Композиция:** Характеристики (GPS, Sunroof, EngineType) становятся **отдельными компонентами**. Класс `Car` **содержит** (компонует) объекты `GPSModule`, `SunroofModule`, `Engine`. Вы можете легко сконфигурировать любую комбинацию характеристик, создавая экземпляры `Car` с нужным набором компонентов. Добавление новой характеристики требует создания нового класса компонента, а не переписывания всей иерархии.

5.  **Сложность тестирования:**
    *   **Наследование:** Чтобы протестировать класс-потомок, вам часто приходится создавать моки или стабы для его родителя, что усложняет настройку тестов.
    *   **Композиция:** Классы, использующие композицию, **легко тестировать**. Вы можете передавать в них **мокированные или заглушечные (stub)** реализации зависимых компонентов, изолируя тестируемую логику.

6.  **Неестественные отношения "is-a":**
    *   **Проблема:** Наследование часто используют не по назначению — только ради переиспользования кода родителя, даже если логического отношения "является" **нет**.
        *   *Классический анти-пример:* `Stack` наследует от `LinkedList` (потому что стек можно реализовать на списке). Но `Stack` *не является* разновидностью `LinkedList`! Он имеет совершенно другой интерфейс (LIFO vs общие операции списка).
    *   **Композиция:** `Stack` **содержал бы** внутри себя `LinkedList` (или `Array`) и **делегировал** ему операции хранения данных, предоставляя только свой специфический интерфейс (push/pop). Отношение "has-a" (`Stack` *has a* storage mechanism) здесь естественно.

**Как правильно использовать композицию (и делегирование):**

1.  **Определите роли:** Выделите отдельные области ответственности (функциональности).
2.  **Создайте интерфейсы:** Определите интерфейсы (или абстрактные классы) для этих ролей. Это контракт, который должен выполнять компонент.
3.  **Реализуйте компоненты:** Создайте конкретные классы, реализующие эти интерфейсы.
4.  **"Включайте" компоненты:** В классе, которому нужна функциональность, объявите поле типа *интерфейса* компонента.
5.  **Делегируйте:** В методах класса-контейнера вызывайте методы объекта-компонента для выполнения работы.
6.  **Внедряйте зависимости:** Передавайте конкретные реализации компонентов в класс-контейнер (обычно через конструктор - Constructor Injection). Это позволяет легко подменять реализации (например, на моки в тестах или на разные версии в рантайме).

**Пример (Кофе):**

*   **Проблема наследования:**
    ```java
    class Coffee { ... }
    class CoffeeWithMilk extends Coffee { ... }
    class CoffeeWithSugar extends Coffee { ... }
    class CoffeeWithMilkAndSugar extends Coffee { ... } // Взрыв иерархии!
    ```
*   **Решение через композицию (и паттерн Декоратор):**
    ```java
    interface Coffee {
        double getCost();
        String getDescription();
    }

    class SimpleCoffee implements Coffee { ... }

    abstract class CoffeeDecorator implements Coffee {
        protected Coffee decoratedCoffee;
        public CoffeeDecorator(Coffee coffee) { this.decoratedCoffee = coffee; }
    }

    class MilkDecorator extends CoffeeDecorator {
        public MilkDecorator(Coffee coffee) { super(coffee); }
        public double getCost() { return decoratedCoffee.getCost() + 0.5; }
        public String getDescription() { return decoratedCoffee.getDescription() + ", Milk"; }
    }

    class SugarDecorator extends CoffeeDecorator { ... } // Аналогично

    // Использование:
    Coffee myCoffee = new SimpleCoffee();
    myCoffee = new MilkDecorator(myCoffee); // Coffee with Milk
    myCoffee = new SugarDecorator(myCoffee); // Coffee with Milk and Sugar
    ```
    *   Здесь `CoffeeDecorator` **имеет** (`has-a`) компонент `Coffee` (композиция) и **делегирует** ему вызовы, добавляя свою функциональность. Мы можем динамически комбинировать декораторы в любом порядке, не создавая взрыва классов.

**Когда наследование ВСЕ ЖЕ уместно:**

1.  **Четкое отношение "is-a":** Когда класс Б *действительно является* специализацией класса А, и между ними есть строгая логическая связь (e.g., `SavingsAccount` *is an* `Account`, `Circle` *is a* `Shape`).
2.  **Полиморфизм:** Когда вам критически важно использовать полиморфизм через базовый класс/интерфейс для группы родственных объектов.
3.  **Переиспользование кода *с* полиморфизмом:** Когда код в базовом классе действительно общий для всех потомков, и вы планируете использовать его полиморфно.
4.  **Расширение фреймворков:** Когда фреймворк явно предназначен для расширения через наследование (хотя и тут сейчас часто предпочитают композицию/делегирование).

**Золотое правило:** **Сначала подумайте о композиции.** Если композиция решает задачу чисто, гибко и без создания искусственных иерархий — используйте ее. Прибегайте к наследованию только тогда, когда существует **настоящее, устойчивое отношение "является" (is-a)**, и вам необходим полиморфизм на уровне этой иерархии. Композиция + программирование на интерфейсах дают гораздо большую **гибкость, модульность и устойчивость к изменениям**.