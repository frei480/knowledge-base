---
tags:
  - АрхитектураПО
---

Паттерн "Стратегия" помогает бороться со следующими антипаттернами и проблемами в коде:

---

### 1. **"Божественный объект" (God Object)**
**Проблема:** Один класс содержит слишком много логики (включая множество вариантов алгоритмов).  
**Как решает "Стратегия":**  
- Выносит алгоритмы в отдельные классы-стратегии  
- Упрощает основной класс (контекст)

**Пример нарушения:**
```python
class OrderProcessor:
    def process(self, order, payment_type):
        if payment_type == "credit_card":
            # 50 строк кода
        elif payment_type == "paypal":
            # 40 строк кода
        elif payment_type == "crypto":
            # 30 строк кода
        # + логика доставки, уведомлений и т.д.
```

---

### 2. **"Длинные методы" (Long Methods)**
**Проблема:** Алгоритмы реализованы в виде больших монолитных методов с ветвлениями.  
**Как решает "Стратегия":**  
- Разбивает алгоритмы на компактные классы  
- Каждая стратегия содержит только один вариант реализации

**Пример нарушения:**
```csharp
public class Calculator {
    public double Calculate(string operation, double a, double b) {
        if (operation == "add") {
            return a + b + /* сложная логика */;
        }
        else if (operation == "multiply") {
            return a * b * /* сложная логика */;
        } // +10 веток
    }
}
```

---

### 3. **Жёсткая связанность (Tight Coupling)**
**Проблема:** Код клиента напрямую зависит от конкретных реализаций алгоритмов.  
**Как решает "Стратегия":**  
- Вводит общий интерфейс стратегий  
- Клиент работает только с абстракцией

**Пример нарушения:**
```python
class Client:
    def execute(self):
        # Прямое использование конкретных классов
        if config.use_quick_sort:
            sorter = QuickSorter()
        else:
            sorter = BubbleSorter()
        sorter.sort(data)
```

---

### 4. **Нарушение OCP (Open-Closed Principle)**
**Проблема:** Для добавления нового алгоритма нужно изменять существующий код.  
**Как решает "Стратегия":**  
- Новые стратегии добавляются без изменения контекста  
- Система расширяется через добавление классов

**Пример нарушения:**
```csharp
public class ReportGenerator {
    public void GenerateReport(string type) {
        switch(type) {
            case "PDF": /* код PDF */ break;
            case "HTML": /* код HTML */ break;
            // Для добавления CSV нужно редактировать этот метод
        }
    }
}
```

---

### 5. **Дублирование кода (Code Duplication)**
**Проблема:** Похожие алгоритмы дублируются в разных классах.  
**Как решает "Стратегия":**  
- Общая логика инкапсулируется в переиспользуемых стратегиях  
- Устраняет копипасту через централизацию кода

**Пример нарушения:**
```python
# В разных классах повторяется схожая логика
class UserService:
    def validate_password(self, pwd):
        # 15 строк проверок

class OrderService:
    def validate_password(self, pwd):
        # Те же 15 строк
```

---

### 6. **Состояние гонки (для параллельных систем)**
**Проблема:** Изменение поведения через флаги/настройки в многопоточной среде.  
**Как решает "Стратегия":**  
- Стратегии являются неизменяемыми (immutable) объектами  
- Переключение стратегий атомарно

**Пример риска:**
```csharp
// Потокобезопасная реализация
public class ImageProcessor {
    private ICompressionStrategy _strategy;
    
    public void SetStrategy(ICompressionStrategy strategy) {
        // Нет риска частичного обновления состояния
        _strategy = strategy;
    }
}
```

---

### 7. **Тестовые сложности**
**Проблема:** Невозможность изолированно тестировать алгоритмы.  
**Как решает "Стратегия":**  
- Каждую стратегию можно тестировать отдельно  
- Контекст тестируется с mock-стратегиями

**Пример проблемы без паттерна:**
```python
def test_processor():
    processor = MegaProcessor()  # Инициализация всего приложения
    result = processor.run()    # Запуск всех алгоритмов сразу
    assert ... # Сложная проверка
```

---

### Главные преимущества применения Стратегии:
1. **Устраняет ветвления** (`if/switch` → полиморфизм)  
2. **Соответствует [[SOLID принципы|SOLID]]**:
   - [[SOLID принципы#^eb6306|Single Responsibility]] (каждая стратегия = одна ответственность)
   - [[SOLID принципы#^97ae80|Open-Closed]]  (расширяется новыми классами)
   - [[SOLID принципы#^905e95|Dependency Inversion]] (зависимости от абстракций)
1. **Упрощает тестирование**  
2. **Повышает переиспользуемость кода**  
3. **Позволяет динамически менять поведение** во время выполнения

Паттерн особенно эффективен в системах, где:
- Есть семейство взаимозаменяемых алгоритмов
- Поведение должно настраиваться в runtime
- Требуется изоляция бизнес-логики от алгоритмов