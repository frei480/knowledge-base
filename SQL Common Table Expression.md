---
tags:
  - SQL
---
**CTE (Common Table Expression)** — это временный именованный результат запроса, который можно использовать в последующих SQL-запросах. CTE улучшает читаемость кода и позволяет структурировать сложные запросы, разбивая их на логические части. 

---

### **Основные особенности CTE**:
1. **Временный результат**: Существует только во время выполнения запроса.
2. **Именованный блок**: Определяется с помощью ключевого слова `WITH`.
3. **Локальная видимость**: Доступен только в рамках одного запроса.
4. **Рекурсия**: Некоторые СУБД (например, PostgreSQL, SQL Server) поддерживают рекурсивные CTE для обработки иерархических данных.

---

### **Синтаксис**:
```sql
WITH название_cte AS (
    SELECT ...  -- Запрос, формирующий CTE
)
SELECT * FROM название_cte;  -- Основной запрос, использующий CTE
```

---

### **Примеры использования**:

#### 1. **Простой CTE**:
```sql
WITH department_avg AS (
    SELECT department, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department
)
SELECT e.name, e.salary, d.avg_salary
FROM employees e
JOIN department_avg d ON e.department = d.department;
```
Здесь CTE `department_avg` вычисляет среднюю зарплату по отделам, которая затем используется в основном запросе.

---

#### 2. **Несколько CTE**:
Можно определить несколько CTE, разделяя их запятыми:
```sql
WITH 
    sales AS (
        SELECT product_id, SUM(quantity) AS total_sold
        FROM orders
        GROUP BY product_id
    ),
    products_info AS (
        SELECT id, name, price
        FROM products
    )
SELECT p.name, s.total_sold, p.price * s.total_sold AS total_revenue
FROM sales s
JOIN products_info p ON s.product_id = p.id;
```

---

#### 3. **Рекурсивный CTE** (для иерархических данных):
```sql
WITH RECURSIVE subordinates AS (
    SELECT id, name, manager_id
    FROM employees
    WHERE id = 1  -- Начальный пункт (например, CEO)
    UNION ALL
    SELECT e.id, e.name, e.manager_id
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates;
```
Этот запрос вернет всех подчиненных для сотрудника с `id = 1` и их подчиненных (рекурсивно).

---

### **Преимущества CTE**:
- **Удобство**: Упрощает сложные запросы, разбивая их на части.
- **Повторное использование**: CTE можно ссылаться несколько раз в основном запросе (в некоторых СУБД).
- **Рекурсия**: Позволяет обрабатывать иерархические данные (например, деревья).
- **Читаемость**: Код становится более понятным по сравнению с вложенными подзапросами.

---

### **CTE vs Подзапросы vs Временные таблицы**:
| **Критерий**       | **CTE**                          | **Подзапрос**                     | **Временная таблица**             |
|---------------------|----------------------------------|-----------------------------------|-----------------------------------|
| **Время жизни**     | Только в рамках запроса          | В рамках запроса                  | До явного удаления или сессии     |
| **Читаемость**      | Высокая (именованные блоки)      | Низкая (вложенные запросы)        | Средняя                           |
| **Рекурсия**        | Поддерживается                   | Не поддерживается                 | Не поддерживается                 |
| **Производительность** | Зависит от оптимизатора СУБД   | Может быть медленнее              | Быстрее (данные сохраняются)      |

---

### **Когда использовать CTE**:
- Для разбивки сложного запроса на логические части.
- При работе с рекурсивными структурами (например, дерево менеджеров).
- Когда нужно переиспользовать результат подзапроса несколько раз.
- Для улучшения читаемости кода.

---

### **Ограничения**:
- В некоторых СУБД CTE может быть материализован (сохранен в памяти), что влияет на производительность.
- Не все СУБД поддерживают рекурсивные CTE (например, MySQL до версии 8.0 — не поддерживал).

CTE — это мощный инструмент для написания чистого и эффективного SQL-кода, особенно при работе с многоуровневыми запросами.