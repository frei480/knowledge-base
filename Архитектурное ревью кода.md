---
tags:
  - АрхитектураПО
---

# Архитектурное Ревью Кода: Детальный Разбор Процесса

Архитектурное ревью кода — это систематический анализ кодовой базы с фокусом на структурных аспектах системы. В отличие от обычного code review, оно оценивает не отдельные пулл-реквесты, а целостность системы в контексте архитектурных принципов.

## Зачем Проводить Архитектурные Ревью?
1. **Выявление скрытых проблем**: Обнаружение антипаттернов ([[опасные антипаттерны в ООП#^006b99|God Class]], [[опасные антипаттерны в ООП#^285f2b|Spaghetti Code]])
2. **Профилактика технического долга**: Раннее выявление архитектурных "запахов"
3. **Обеспечение масштабируемости**: Проверка готовности к росту нагрузки
4. **Соблюдение стандартов**: Контроль соответствия архитектурным принципам ([[SOLID принципы|SOLID]], DDD)
5. **Передача знаний**: Коллективное понимание архитектуры командой

---

# Пошаговый Процесс Проведения

## 1. Подготовка (2-4 часа)
- **Выбор области**: Определите критичные модули (ядро системы, часто изменяемые компоненты)
- **Сбор метрик**: Используйте инструменты статического анализа:
  ```bash
  # Для C#
  dotnet tool install -g ndepend
  ndepend myproject.sln
  
  # Для Python
  pip install radon
  radon cc path/to/project -a
  ```
- **Подготовка диаграмм**:
  - Dependency Graph (Mermaid пример):
    ```mermaid
    graph TD
      A[OrderService] --> B[PaymentGateway]
      A --> C[InventoryService]
      B --> D[BankAPI]
      C --> E[Database]
    ```

## 2. Анализ Архитектурных Слоев (4-8 часов)
Проверка соблюдения границ между слоями:

| Слой | Проверяемые аспекты | Инструменты |
|------|----------------------|-------------|
| **Presentation** | Нет бизнес-логики, тонкие контроллеры | Проверка вызовов из контроллеров |
| **Application** | Оркестрация потоков, нет доменной логики | Поиск анемичных сервисов |
| **Domain** | Чистая бизнес-логика, нет зависимостей от инфраструктуры | Анализ ссылок на внешние библиотеки |
| **Infrastructure** | Реализация репозиториев, внешние интеграции | Проверка зависимостей от конкретных технологий |

## 3. Проверка Ключевых Архитектурных Атрибутов
Оцените систему по шкале 1-5 для каждого атрибута:

```python
# Пример оценки на Python
attributes = {
    "Масштабируемость": 4,
    "Отказоустойчивость": 3,
    "Производительность": 4,
    "Безопасность": 2,  # Требует улучшений
    "Тестируемость": 5
}
```

## 4. Выявление Архитектурных Антипаттернов
**Типичные проблемы и решения:**

1. **Нарушение границ контекстов (Bounded Context)**
   - **Симптом**: Класс `Order` знает о внутренней структуре `UserProfile`
   - **Решение**: Ввести антикоррупционный слой
     ```csharp
     // Вместо:
     var address = order.User.Address;
     
     // Стало:
     var address = userService.GetShippingAddress(order.UserId);
     ```

2. **Циклические зависимости**
   - **Обнаружение**:
     ```bash
     # NDepend для C#
     SELECT ASSEMBLIES WHERE HasCyclicReferences
     ```
   - **Решение**: Введение интерфейсов в отдельном слое

3. **Нарушение принципа инверсии зависимостей**
   - **Симптом**: Прямое создание зависимостей в конструкторе
     ```python
     class OrderService:
         def __init__(self):
             self.repository = SqlOrderRepository()  # Нарушение!
     ```
   - **Решение**: Внедрение зависимостей
     ```python
     class OrderService:
         def __init__(self, repository: IOrderRepository):
             self.repository = repository
     ```

## 5. Анализ Модульности (3-5 часов)
- **Метрики**:
  - Связность (Cohesion): >7/10
  - Сцепление (Coupling): <5 внешних зависимостей
  - Стабильность (I = Fan-out / (Fan-in + Fan-out)): 0.3-0.7

- **Инструменты**:
  - C#: NDepend "Abstractness vs Instability"
  - Python: `pydeps` для визуализации зависимостей

## 6. Оценка Тестовой Стратегии
1. **Пирамида тестирования**:
   - Соотношение юнит/интеграционных/e2e тестов: 70/20/10
2. **Тестопригодность архитектуры**:
   - Mockability ключевых компонентов
   - Время выполнения тестов: <10 мин для полного набора

## 7. Проведение Воркшопа (4-8 часов)
- **Формат**: Групповая сессия с архитектором и старшими разработчиками
- **Техники**:
  - "Архитектурные кадры": Анализ типичных сценариев
  - "Что, если?": Оценка реакции на изменения требований
  - Сравнение с reference-архитектурами

## 8. Документирование Результатов
**Отчет должен включать**:
1. Топ-3 критические проблемы
2. Карта технического долга:
   ```markdown
   | Модуль          | Проблема               | Приоритет | Оценка усилий |
   |-----------------|------------------------|-----------|---------------|
   | PaymentService  | Прямые вызовы БД      | Высокий   | 5 чел/дней    |
   | OrderProcessing | God Class (1200 LOC)  | Средний   | 3 чел/дней    |
   ```
3. Рекомендации по [[рефакторинг|рефакторингу]]
4. План миграции для критичных компонентов

---

# Практические Инструменты

## Для C#:
1. **Visual Studio Architecture Tools**:
   - Layer Diagrams
   - Dependency Validation
2. **NDepend**: Статический анализ
3. **ReSharper**: Поиск архитектурных запахов

## Для Python:
1. **Pyreverse**: Генерация диаграмм классов
   ```bash
   pyreverse -o png -p myproject .
   ```
2. **Radon**: Анализ сложности
   ```bash
   radon raw -s mymodule.py
   ```
3. **Bandit**: Безопасность архитектуры

---

# Частота Проведения
| Тип системы         | Частота   | Длительность |
|---------------------|-----------|--------------|
| Критичные системы   | Квартально| 3-5 дней     |
| Стандартные проекты | Раз в год | 2-3 дня      |
| Legacy-системы      | Перед изменениями | 1-2 дня |

---

# Реальные Кейсы Из Практики

**Кейс 1: Электронная коммерция (C#)**
- **Проблема**: OrderService (2500 LOC) с логикой оплаты, доставки и инвентаризации
- **Решение**:
  1. Разделение на:
     - PaymentService
     - ShippingOrchestrator
     - InventoryManager
  2. Введение шины событий для коммуникации

**Кейс 2: Data Pipeline (Python)**
- **Проблема**: Монолитный скрипт обработки данных
- **Решение**:
  ```python
  # Было:
  def process_data():
      # 500 строк кода
      
  # Стало:
  class DataPipeline:
      def __init__(self, extractor, transformer, loader):
          self.extractor = extractor
          self.transformer = transformer
          self.loader = loader
      
      def run(self):
          data = self.extractor.execute()
          transformed = self.transformer.execute(data)
          self.loader.execute(transformed)
  ```

---

# Советы Для Эффективных Ревью
1. **Фокусируйтесь на критическом**: 20% кода дает 80% проблем
2. **Используйте визуализацию**: Диаграммы > текстовые описания
3. **Вовлекайте команду**: Проводите совместные сессии
4. **Связывайте с метриками**: Цифры убедительнее мнений
5. **Предлагайте решения**: Не только критика, но и пути исправления

Архитектурное ревью — не поиск виноватых, а инвестиция в будущее системы. Регулярное проведение снижает стоимость поддержки на 30-40% по данным IEEE.