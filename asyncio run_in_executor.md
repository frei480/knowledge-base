---
tags:
  - python
---
Метод `run_in_executor` в библиотеке `asyncio` позволяет **запускать синхронные (блокирующие) функции в отдельных потоках или процессах**, чтобы не блокировать основной event loop асинхронного приложения. Это особенно полезно, когда вам нужно совместить асинхронный код с операциями, которые по своей природе блокируют выполнение (например, ввод/вывод, вычисления).

---

### **Как это работает?**
- **Event Loop и Блокирующие операции**: 
  Асинхронный код работает на основе event loop, который управляет задачами. Если вызвать синхронную блокирующую функцию (например, `input()`, `time.sleep()`, чтение файла) напрямую в асинхронной корутине, это **заморозит весь event loop** до завершения операции. Другие задачи не смогут выполняться, пока функция не вернет результат.

- **Решение через `run_in_executor`**:
  Метод запускает блокирующую функцию в фоновом потоке (или процессе), позволяя event loop продолжать работу. Результат функции возвращается в виде асинхронного объекта (`Future`), который можно ожидать через `await`.

---

### **Пример из вашего кода**
В интерактивном клиенте используется `run_in_executor` для чтения пользовательского ввода:
```python
message = await asyncio.get_event_loop().run_in_executor(
    None, input, ">>> Введите сообщение: "
)
```
- **Что здесь происходит**:
  1. `input(">>> Введите сообщение: ")` — синхронная функция, которая блокирует выполнение, пока пользователь не введет данные.
  2. `run_in_executor` запускает `input` в отдельном потоке (по умолчанию используется `ThreadPoolExecutor`).
  3. Event loop продолжает обрабатывать другие задачи (например, получение сообщений от сервера через WebSocket), пока пользователь не введет текст.
  4. Как только пользователь вводит сообщение, `await` возвращает результат, и клиент отправляет его через WebSocket.

---

### **Ключевые параметры**
1. **Первый аргумент (`executor`)**:
   - Если `None` — используется стандартный `ThreadPoolExecutor`.
   - Можно передать кастомный исполнитель (например, `ProcessPoolExecutor` для CPU-задач).

2. **Функция и аргументы**:
   - Следующие аргументы — сама функция (`input`) и её аргументы (`">>> Введите сообщение: "`).

---

### **Что было бы без run_in_executor?**
Если убрать `run_in_executor` и вызвать `input()` напрямую:
```python
message = input(">>> Введите сообщение: ")  # Синхронный вызов
```
Event loop заблокируется на время ввода данных. Пока пользователь не нажмет Enter, клиент не сможет получать сообщения от сервера.

---

### **Альтернативы и улучшения**
1. **`asyncio.to_thread()` (Python 3.9+)**:
   Более удобный аналог:
   ```python
   message = await asyncio.to_thread(input, ">>> Введите сообщение: ")
   ```

2. **Использование `ProcessPoolExecutor`**:
   Для тяжелых CPU-задач (например, вычислений):
   ```python
   from concurrent.futures import ProcessPoolExecutor

   with ProcessPoolExecutor() as executor:
       result = await loop.run_in_executor(executor, cpu_intensive_function)
   ```

---

### **Важные нюансы**
- **Потоки vs Процессы**:
  - `ThreadPoolExecutor` подходит для I/O-операций (сеть, файлы).
  - `ProcessPoolExecutor` — для CPU-bound задач (параллельные вычисления).

- **Осторожность с общим состоянием**:
  При работе с потоками избегайте изменений общих переменных — это может привести к состоянию гонки.

- **Отмена задач**:
  Задачи, запущенные через `run_in_executor`, нельзя отменить стандартными методами asyncio.

---

### **Итог**
`run_in_executor` — это мост между асинхронным и синхронным миром. Он позволяет интегрировать блокирующий код в асинхронное приложение без «заморозки» event loop. В вашем примере он используется для того, чтобы интерактивный клиент мог одновременно:
- Ожидать ввод пользователя (блокирующая операция),
- Принимать сообщения от сервера через WebSocket (асинхронная операция).