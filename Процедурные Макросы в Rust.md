---
tags:
  - rust
---
[[–û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è –≤ Rust]]
–ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã –≤ Rust ‚Äî —ç—Ç–æ –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –º–µ—Ç–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π –∫–æ–¥ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã—Ö –º–∞–∫—Ä–æ—Å–æ–≤ (`macro_rules!`), –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã –¥–∞—é—Ç –ø–æ–ª–Ω—É—é —Å–≤–æ–±–æ–¥—É –∑–∞ —Å—á—ë—Ç —Ä–∞–±–æ—Ç—ã —Å –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–º —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–º –¥–µ—Ä–µ–≤–æ–º (AST). –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä—ë–º –∏—Ö –ø–æ–¥—Ä–æ–±–Ω–æ.

---

# üì¶ –û—Å–Ω–æ–≤—ã –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö –ú–∞–∫—Ä–æ—Å–æ–≤
–ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã —Ä–µ–∞–ª–∏–∑—É—é—Ç—Å—è –≤ **–æ—Ç–¥–µ–ª—å–Ω—ã—Ö [[Crate –≤ Rust|–∫—Ä–µ–π—Ç–∞—Ö]]** —Å —É–∫–∞–∑–∞–Ω–∏–µ–º `proc-macro = true` –≤ `Cargo.toml`:

```toml
[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
proc-macro2 = "1.0"
```

## –¢—Ä–∏ –¢–∏–ø–∞ –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö –ú–∞–∫—Ä–æ—Å–æ–≤:
1. **Derive-–º–∞–∫—Ä–æ—Å—ã** (–Ω–∞–∏–±–æ–ª–µ–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–µ)
2. **–ê—Ç—Ä–∏–±—É—Ç–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã**
3. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã**

---

# üõ†Ô∏è 1. Derive-–º–∞–∫—Ä–æ—Å—ã
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç—ã –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π.

## –ü—Ä–∏–º–µ—Ä: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è Builder-–ø–∞—Ç—Ç–µ—Ä–Ω–∞
**–¶–µ–ª—å:** –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—è –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.

```rust
#[derive(Builder)]
struct User {
    id: i32,
    name: String,
    email: Option<String>,
}

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç:
impl User {
    pub fn builder() -> UserBuilder {
        UserBuilder::default()
    }
}
```

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è (`src/lib.rs`):
```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let builder_name = syn::Ident::new(&format!("{}Builder", name), name.span());

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–ª–µ–π –¥–ª—è –±–∏–ª–¥–µ—Ä–∞
    let fields = if let syn::Data::Struct(syn::DataStruct {
        fields: syn::Fields::Named(ref fields),
        ..
    }) = input.data
    {
        &fields.named
    } else {
        panic!("Only structs with named fields are supported");
    };

    let builder_fields = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! { #name: std::option::Option<#ty> }
    });

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ set_*
    let set_methods = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! {
            pub fn #name(&mut self, value: #ty) -> &mut Self {
                self.#name = Some(value);
                self
            }
        }
    });

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–µ—Ç–æ–¥–∞ build
    let build_checks = fields.iter().map(|f| {
        let name = &f.ident;
        quote! {
            #name: self.#name.clone().ok_or(format!("Field {} is missing", stringify!(#name)))?
        }
    });

    let expanded = quote! {
        #[derive(Default)]
        struct #builder_name {
            #(#builder_fields,)*
        }

        impl #builder_name {
            #(#set_methods)*

            pub fn build(&mut self) -> Result<#name, String> {
                Ok(#name {
                    #(#build_checks,)*
                })
            }
        }

        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name::default()
            }
        }
    };

    expanded.into()
}
```

---

# üè∑Ô∏è 2. –ê—Ç—Ä–∏–±—É—Ç–Ω—ã–µ –ú–∞–∫—Ä–æ—Å—ã
–ò–∑–º–µ–Ω—è—é—Ç –∞–Ω–Ω–æ—Ç–∏—Ä—É–µ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç, –¥–æ–±–∞–≤–ª—è—è –∏–ª–∏ –∏–∑–º–µ–Ω—è—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å.

## –ü—Ä–∏–º–µ—Ä: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –í—ã–∑–æ–≤–æ–≤ –§—É–Ω–∫—Ü–∏–∏
```rust
#[log_calls]
fn expensive_operation(n: i32) -> i32 {
    // –î–ª–∏—Ç–µ–ª—å–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è
    n * 2
}
```

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è:
```rust
#[proc_macro_attribute]
pub fn log_calls(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as syn::ItemFn);
    let fn_name = &input.sig.ident;
    let block = &input.block;

    let expanded = quote! {
        fn #fn_name() -> i32 {
            println!("[LOG] Calling {}", stringify!(#fn_name));
            let start = std::time::Instant::now();
            let result = #block;
            println!("[LOG] {} completed in {:?}", stringify!(#fn_name), start.elapsed());
            result
        }
    };

    expanded.into()
}
```

---

# üìû 3. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ú–∞–∫—Ä–æ—Å—ã
–í—ã–≥–ª—è–¥—è—Ç –∫–∞–∫ –≤—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π –∏ —Ä–∞–±–æ—Ç–∞—é—Ç —Å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º–∏ —Ç–æ–∫–µ–Ω–∞–º–∏.

## –ü—Ä–∏–º–µ—Ä: SQL-–∑–∞–ø—Ä–æ—Å—ã –° –ü—Ä–æ–≤–µ—Ä–∫–æ–π –ù–∞ –≠—Ç–∞–ø–µ –ö–æ–º–ø–∏–ª—è—Ü–∏–∏
```rust
let query = sql!(SELECT * FROM users WHERE age > 10);
```

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è:
```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as sql_macro::Input);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ SQL –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–∞
    let validated_query = validate_sql(&input);
    
    quote! {
        {
            use sqlx::query;
            query(#validated_query)
        }
    }.into()
}
```

---

# üîç –ö–ª—é—á–µ–≤—ã–µ –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –î–ª—è –†–∞–±–æ—Ç—ã

## 1. `syn` ‚Äî –ü–∞—Ä—Å–∏–Ω–≥ –í—Ö–æ–¥–Ω—ã—Ö –î–∞–Ω–Ω—ã—Ö
–ü–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–±–∏—Ä–∞—Ç—å `TokenStream` –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ AST-—É–∑–ª—ã:
```rust
use syn::{parse_macro_input, DeriveInput, ItemFn};

// –î–ª—è derive-–º–∞–∫—Ä–æ—Å–æ–≤
let input = parse_macro_input!(input as DeriveInput);

// –î–ª—è —Ñ—É–Ω–∫—Ü–∏–π
let input = parse_macro_input!(input as ItemFn);
```

## 2. `quote` ‚Äî –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ö–æ–¥–∞
–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç Rust-–∫–æ–¥ –æ–±—Ä–∞—Ç–Ω–æ –≤ `TokenStream`:
```rust
let name = syn::Ident::new("MyStruct", proc_macro2::Span::call_site());
let output = quote! {
    impl #name {
        fn new() -> Self {
            Self
        }
    }
};
```

## 3. `proc_macro2` ‚Äî –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
–†–∞–±–æ—Ç–∞ —Å —Ç–æ–∫–µ–Ω–∞–º–∏ –≤–Ω–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –º–∞–∫—Ä–æ—Å–∞:
```rust
use proc_macro2::TokenStream;
let tokens: TokenStream = /* ... */;
```

---

# üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö –ú–∞–∫—Ä–æ—Å–æ–≤
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `proc_macro2` –∏ `syn` –¥–ª—è –º–æ–¥—É–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:

```rust
#[test]
fn test_builder_macro() {
    let input = r#"
        #[derive(Builder)]
        struct User {
            id: i32,
            name: String,
        }
    "#;
    
    let parsed = syn::parse_str(input).unwrap();
    let output = derive_builder(parsed.into());
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞
    assert!(output.to_string().contains("struct UserBuilder"));
}
```

---

# ‚ö†Ô∏è –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ò –°–ª–æ–∂–Ω–æ—Å—Ç–∏
1. **–û—Ç–ª–∞–¥–∫–∞**: –û—à–∏–±–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –≤ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –∫–æ–¥–µ
2. **–í—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏**: –¢—è–∂—ë–ª—ã–µ –º–∞–∫—Ä–æ—Å—ã –∑–∞–º–µ–¥–ª—è—é—Ç —Å–±–æ—Ä–∫—É
3. **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å**: API `proc_macro` –ø–æ–∫–∞ –Ω–µ —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é
4. **–°–ª–æ–∂–Ω–æ—Å—Ç—å AST**: –¢—Ä–µ–±—É–µ—Ç –≥–ª—É–±–æ–∫–æ–≥–æ –ø–æ–Ω–∏–º–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫–æ–¥–∞ Rust

---

# üöÄ –õ—É—á—à–∏–µ –ü—Ä–∞–∫—Ç–∏–∫–∏
1. **–†–∞–∑–¥–µ–ª—è–π—Ç–µ –ª–æ–≥–∏–∫—É**: –í—ã–Ω–æ—Å–∏—Ç–µ —Å–ª–æ–∂–Ω—É—é –ª–æ–≥–∏–∫—É –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
2. **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫**:
   ```rust
   syn::Error::new_spanned(field, "Unsupported field type")
       .to_compile_error()
       .into()
   ```
3. **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–º–æ—â–Ω–∏–∫–∏**:
   - `darling` –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã —Å –∞—Ç—Ä–∏–±—É—Ç–∞–º–∏
   - `heck` –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–º–µ–Ω–æ–≤–∞–Ω–∏—è
4. **–ö—ç—à–∏—Ä—É–π—Ç–µ**: –ì–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–æ–¥ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏

---

# üí° –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –¢–µ—Ö–Ω–∏–∫–∏

## 1. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ü–æ–∑–∏—Ü–∏–π –í –ö–æ–¥–µ
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `Span` –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö:
```rust
let span = input.ident.span();
syn::Error::new(span, "Custom error message").to_compile_error().into()
```

## 2. –û–±—Ä–∞–±–æ—Ç–∫–∞ Generic-—Ç–∏–ø–æ–≤
```rust
let generics = &input.generics;
let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

quote! {
    impl #impl_generics MyTrait for #name #ty_generics #where_clause {
        // ...
    }
}
```

## 3. –†–∞–±–æ—Ç–∞ –° –ê—Ç—Ä–∏–±—É—Ç–∞–º–∏
```rust
#[derive(Builder, Debug, PartialEq)]
#[builder(verbose)]
struct User { /* ... */ }
```

–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∞—Ç—Ä–∏–±—É—Ç–æ–≤:
```rust
for attr in &input.attrs {
    if attr.path().is_ident("builder") {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—Ç—Ä–∏–±—É—Ç–∞
    }
}
```

---

# üåü –†–µ–∞–ª—å–Ω—ã–µ –ü—Ä–∏–º–µ—Ä—ã –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
1. **`serde`**: `#[derive(Serialize, Deserialize)]`
2. **`tokio`**: `#[tokio::main]`
3. **`async-trait`**: –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç—Ä–µ–π—Ç–æ–≤ –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ
4. **`sqlx`**: –ü—Ä–æ–≤–µ—Ä–∫–∞ SQL-–∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
5. **`mockall`**: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –º–æ–∫-–æ–±—ä–µ–∫—Ç–æ–≤

---

# üìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –° –î–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã–º–∏ –ú–∞–∫—Ä–æ—Å–∞–º–∏
| –ö—Ä–∏—Ç–µ—Ä–∏–π               | –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã          | `macro_rules!`              |
|------------------------|-------------------------------|-----------------------------|
| –ú–æ—â–Ω–æ—Å—Ç—å               | –ü–æ–ª–Ω–∞—è –ø–æ –¢—å—é—Ä–∏–Ω–≥—É            | –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è                |
| –°–ª–æ–∂–Ω–æ—Å—Ç—å              | –í—ã—Å–æ–∫–∞—è                       | –£–º–µ—Ä–µ–Ω–Ω–∞—è                  |
| –†–∞–±–æ—Ç–∞ —Å AST           | –ü–æ–ª–Ω—ã–π –¥–æ—Å—Ç—É–ø                 | –¢–æ–ª—å–∫–æ –ø–∞—Ç—Ç–µ—Ä–Ω-–º–∞—Ç—á–∏–Ω–≥     |
| –í—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏       | –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ                  | –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ                |
| –û—Ç–ª–∞–¥–∫–∞                | –°–ª–æ–∂–Ω–∞—è                       | –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—Å—Ç–∞—è       |
| –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ | –ü–æ–ª–Ω–æ–µ (–∫–∞–∫ –æ–±—ã—á–Ω—ã–π –∫–æ–¥ Rust) | –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ               |

---

# üèÅ –ò—Ç–æ–≥
–ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã –≤ Rust ‚Äî —ç—Ç–æ –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç:
1. –°–æ–∑–¥–∞–≤–∞—Ç—å —Å–ª–æ–∂–Ω—ã–µ DSL (–ø—Ä–µ–¥–º–µ—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —è–∑—ã–∫–∏)
2. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —à–∞–±–ª–æ–Ω–Ω—ã–π –∫–æ–¥
3. –í—ã–ø–æ–ª–Ω—è—Ç—å —Å–ª–æ–∂–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
4. –†–∞—Å—à–∏—Ä—è—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —è–∑—ã–∫–∞

–î–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã:
1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `syn` –∏ `quote`
2. –¢–µ—Å—Ç–∏—Ä—É–π—Ç–µ —Å –ø–æ–º–æ—â—å—é `proc-macro2`
3. –°–ª–µ–¥—É–π—Ç–µ –ª—É—á—à–∏–º –ø—Ä–∞–∫—Ç–∏–∫–∞–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—à–∏–±–æ–∫
4. –ò–∑—É—á–∞–π—Ç–µ AST —á–µ—Ä–µ–∑ `cargo expand`
